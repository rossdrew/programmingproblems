package com.rox.prob.adventofcode.y2017;

import java.util.Arrays;

/**
 * --- Day 1: Inverse Captcha ---
 *
 * The night before Christmas, one of Santa's Elves calls you in a panic. "The printer's broken! We can't
 * print the Naughty or Nice List!" By the time you make it to sub-basement 17, there are only a few minutes
 * until midnight. "We have a big problem," she says; "there must be almost fifty bugs in this system, but nothing
 * else can print The List. Stand in this square, quick! There's no time to explain; if you can convince them to
 * pay you in stars, you'll be able to--" She pulls a lever and the world goes blurry.
 *
 * When your eyes can focus again, everything seems a lot more pixelated than before. She must have sent you inside
 * the computer! You check the system clock: 25 milliseconds until midnight. With that much time, you should be able
 * to collect all fifty stars by December 25th.
 *
 * Collect stars by solving puzzles. Two puzzles will be made available on each day millisecond in the advent calendar;
 * the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!
 *
 * You're standing in a room with "digitization quarantine" written in LEDs along one wall. The only door is locked,
 * but it includes a small interface. "Restricted Area - Strictly No Digitized Users Allowed."
 *
 *  It goes on to explain that you may only leave by solving a captcha to prove you're not a human. Apparently, you
 *  only get one millisecond to solve the captcha: too fast for a normal human, but it feels like hours to you.
 *
 * The captcha requires you to review a sequence of digits (your puzzle input) and find the sum of all digits that
 * match the next digit in the list. The list is circular, so the digit after the last digit is the first digit in the
 * list.
 *
 * For example:
 *
 * 1122 produces a sum of 3 (1 + 2) because the first digit (1) matches the second digit and the third digit (2)matches the fourth digit.
 * 1111 produces 4 because each digit (all 1) matches the next.
 * 1234 produces 0 because no digit matches the next.
 * 91212129 produces 9 because the only digit that matches the next one is the last digit, 9.
 *
 * Puzzle Input: 36743676522426214741687639282183216978128565594112364817283598621384839756628424146779311928318383597235968644687665159591573413233616717112157752469191845757712928347624726438516211153946892241449523148419426259291788938621886334734497823163281389389853675932246734153563861233894952657625868415432316155487242813798425779743561987563734944962846865263722712768674838244444385768568489842989878163655771847362656153372265945464128668412439248966939398765446171855144544285463517258749813731314365947372548811434646381595273172982466142248474238762554858654679415418693478512641864168398722199638775667744977941183772494538685398862344164521446115925528534491788728448668455349588972443295391385389551783289417349823383324748411689198219329996666752251815562522759374542652969147696419669914534586732436912798519697722586795746371697338416716842214313393228587413399534716394984183943123375517819622837972796431166264646432893478557659387795573234889141897313158457637142238315327877493994933514112645586351127139429281675912366669475931711974332271368287413985682374943195886455927839573986464555141679291998645936683639162588375974549467767623463935561847869527383395278248952314792112113126231246742753119748113828843917812547224498319849947517745625844819175973986843636628414965664466582172419197227695368492433353199233558872319529626825788288176275546566474824257336863977574347328469153319428883748696399544974133392589823343773897313173336568883385364166336362398636684459886283964242249228938383219255513996468586953519638111599935229115228837559242752925943653623682985576323929415445443378189472782454958232341986626791182861644112974418239286486722654442144851173538756859647218768134572858331849543266169672745221391659363674921469481143686952478771714585793322926824623482923579986434741714167134346384551362664177865452895348948953472328966995731169672573555621939584872187999325322327893336736611929752613241935211664248961527687778371971259654541239471766714469122213793348414477789271187324629397292446879752673
 * Solution: 1069
 *
 * --- Part Two ---
 *
 * You notice a progress bar that jumps to 50% completion. Apparently, the door isn't yet satisfied, but it did emit a star as encouragement. The instructions change:
 *
 * Now, instead of considering the next digit, it wants you to consider the digit halfway around the circular list. That is, if your list contains 10 items, only include a digit in your sum if the digit 10/2 = 5 steps forward matches it. Fortunately, your list has an even number of elements.
 *
 * For example:
 *
 * 1212 produces 6: the list contains 4 items, and all four digits match the digit 2 items ahead.
 * 1221 produces 0, because every comparison is between a 1 and a 2.
 * 123425 produces 4, because both 2s match each other, but no other digit has a match.
 * 123123 produces 12.
 * 12131415 produces 4.
 *
 * Puzzle Input: 36743676522426214741687639282183216978128565594112364817283598621384839756628424146779311928318383597235968644687665159591573413233616717112157752469191845757712928347624726438516211153946892241449523148419426259291788938621886334734497823163281389389853675932246734153563861233894952657625868415432316155487242813798425779743561987563734944962846865263722712768674838244444385768568489842989878163655771847362656153372265945464128668412439248966939398765446171855144544285463517258749813731314365947372548811434646381595273172982466142248474238762554858654679415418693478512641864168398722199638775667744977941183772494538685398862344164521446115925528534491788728448668455349588972443295391385389551783289417349823383324748411689198219329996666752251815562522759374542652969147696419669914534586732436912798519697722586795746371697338416716842214313393228587413399534716394984183943123375517819622837972796431166264646432893478557659387795573234889141897313158457637142238315327877493994933514112645586351127139429281675912366669475931711974332271368287413985682374943195886455927839573986464555141679291998645936683639162588375974549467767623463935561847869527383395278248952314792112113126231246742753119748113828843917812547224498319849947517745625844819175973986843636628414965664466582172419197227695368492433353199233558872319529626825788288176275546566474824257336863977574347328469153319428883748696399544974133392589823343773897313173336568883385364166336362398636684459886283964242249228938383219255513996468586953519638111599935229115228837559242752925943653623682985576323929415445443378189472782454958232341986626791182861644112974418239286486722654442144851173538756859647218768134572858331849543266169672745221391659363674921469481143686952478771714585793322926824623482923579986434741714167134346384551362664177865452895348948953472328966995731169672573555621939584872187999325322327893336736611929752613241935211664248961527687778371971259654541239471766714469122213793348414477789271187324629397292446879752673
 * Solution: 1268
 */
public class Day1 {
    /**
     * Rotation calculation method.
     */
    private enum RotationMethod {
        /** An integer based rotation. e.g. 'rotate 5 steps' to rotate 5 modular steps */
        INTEGER,
        /** A division based rotation. e.g. 'rotate by size x 0.5' for a complete half rotation */
        DIVISION
    }

    private RotationMethod rotationMethod;
    private int integerRotation;
    private float divisionalRotation;

    public Day1(final int rotation){
        this.integerRotation = rotation;
        rotationMethod = RotationMethod.INTEGER;
    }

    public Day1(final float rotation){
        if (rotation > 1)
            throw new RuntimeException("Fractional integer rotation (" + rotation + ") not possible");

        this.rotationMethod = RotationMethod.DIVISION;
        this.divisionalRotation = rotation;
    }

    public long solution(String digitString){
        char[] characterDigits = digitString.toCharArray();
        int[] digits = new int[characterDigits.length];
        for (int i=0; i<characterDigits.length; i++)
            digits[i] = Character.getNumericValue(characterDigits[i]);

        System.out.println("INPUT: " + Arrays.toString(digits));

        return solution(digits);
    }

    public long solution(int[] digit){
        final int rotation = rotationMethod == RotationMethod.DIVISION ? (int)Math.floor(digit.length * divisionalRotation) : integerRotation;

        long sum = 0;

        for (int i=0; i<digit.length; i++){
            int compareDigit = (i+rotation) % digit.length ;
            //System.out.println(i + " + " + rotation + " % " + digit.length + " = " + compareDigit + " -> " + digit[i] + "==" + digit[compareDigit]);
            if (digit[i] == digit[compareDigit])
                sum += digit[i];
        }

        return sum;
    }
}
